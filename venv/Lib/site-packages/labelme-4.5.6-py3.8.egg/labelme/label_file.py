import base64
import contextlib
import io
import json
import os.path as osp

import PIL.Image

from labelme import __version__
from labelme.logger import logger
from labelme import PY2
from labelme import QT4
from labelme import utils

import time

PIL.Image.MAX_IMAGE_PIXELS = None



@contextlib.contextmanager
def open(name, mode):
    assert mode in ["r", "w"]
    if PY2:
        mode += "b"
        encoding = None
    else:
        encoding = "utf-8"
    yield io.open(name, mode, encoding=encoding)
    return


class LabelFileError(Exception):
    pass


class LabelFile(object):

    suffix = ".json"

    def __init__(self, filename=None):
        self.shapes = []
        self.imagePath = None
        self.imageData = None
        if filename is not None:
            self.load(filename)
        self.filename = filename

        self.supercategory = [
            "flatness", "walkway", "paved_state", "block_state", "block_kind", "outcurb", "restspace", "sidegap",
            "sewer", "brailleblock", "continuity", "ramp", "bicycleroad", "planecrosswalk", "steepramp", "bump",
            "weed", "floor", "flowerbed", "parkspace", "tierbump", "stone", "enterrail", "fireshutter", "stair",
            "stair_broken", "wall", "window", "pillar", "lift", "door", "lift_door", "resting_place_roof",
            "reception_desk", "protect_wall", "handle", "lift_button", "direction_sign", "sign_disabled",
            "braille_sign", "chair", "chair_back", "chair_handle", "number_ticket_machine", "beverage_vending_machine",
            "beverage_desk", "trash_can", "mailbox"
        ]
        self.category_name = {"flatness_A": "A(Very Good)", "flatness_B": "B(Good)", "flatness_C": "C(Fair)",
                              "flatness_D": "D(Poor)", "flatness_E": "E(Very poor)",
                              "walkway_paved": "포장도로", "walkway_block": "보도블럭",
                              "paved_state_broken": "포장도로 파손", "paved_state_normal": "포장도로 정상",
                              "block_state_broken": "보도블럭 파손", "block_state_normal": "보도블럭 정상",
                              "block_kind_bad": "주행성 나쁨", "block_kind_good": "주행성 좋음",
                              "outcurb_rectangle": "사각모서리 연석 정상", "outcurb_slide": "경사형 연석 정상",
                              "outcurb_rectangle_broken": "사각모서리 연석 파손", "outcurb_slide_broken": "경사형 연석 파손",
                              "restspace": "휴식참",
                              "sidegap_in": "문턱 (실내)", "sidegap_out": "문턱 (실외)",
                              "sewer_cross": "격자형 배수구", "sewer_line": "비 격자형 배수구",
                              "brailleblock_dot": "점형블록", "brailleblock_line": "선형블록",
                              "brailleblock_dot_broken": "점형블록 파손", "brailleblock_line_broken": "선형블록 파손",
                              "continuity_tree": "연속하지 않음 (가로수영역)", "continuity_manhole": "연속하지 않음 (맨홀)",
                              "ramp_yes": "미끄럼방지 있는 경사로", "ramp_no": "미끄럼방지 없는 경사로",
                              "bicycleroad_broken": "자전거 도로 파손", "bicycleroad_normal": "자전거 도로 정상",
                              "planecrosswalk_broken": "평면횡단보도 파손", "planecrosswalk_normal": "평면횡단보도 정상",
                              "steepramp": "간이 부분경사로",
                              "bump_slow": "과속방지턱", "bump_zigzag": "지그재그형 도로",
                              "weed": "잡초",
                              "floor_normal": "복도 바닥 정상", "floor_broken": "복도바닥 파손",
                              "flowerbed": "화단",
                              "parkspace": "주차공간",
                              "tierbump": "타이어 방지턱",
                              "stone": "경관용 돌",
                              "enterrail": "주출입문 레일",
                              "fireshutter": "방화셔터 바닥홈",
                              "stair_normal": "계단",
                              "stair_broken": "계단 파손",
                              "wall": "벽",
                              "window_sliding": "미서기창", "window_casement": "여닫이창",
                              "pillar": "기둥",
                              "lift": "승강기 (시설)",
                              "door_normal": "문", "door_rotation": "회전문",
                              "lift_door": "승강기 출입문",
                              "resting_place_roof": "휴게시설",
                              "reception_desk": "하부공간이 있는 접수대",
                              "protect_wall_protective": "방호울타리", "protect_wall_guardrail": "접근방지용 난간",
                              "protect_wall_kickplate": "킥플레이트",
                              "handle_vertical": "수직막대형", "handle_lever": "레버형", "handle_circular": "원형손잡이",
                              "lift_button_normal": "일반(조작설비영역)", "lift_button_openarea": "문열림닫침 영역",
                              "lift_button_layer": "층수영역", "lift_button_emergency": "비상벨영역",
                              "direction_sign_left": "왼쪽이동표식","direction_sign_right": "오른쪽이동표식",
                              "direction_sign_straight": "화살표 (후진/직진 포함)", "direction_sign_exit": "출구표식",
                              "sign_disabled_toilet": "(장애인) 화장실표시판", "sign_disabled_parking": "(장애인) 주차표지판",
                              "sign_disabled_elevator": "(장애인) 교통약자 전용 엘리베이터 표지판",
                              "sign_disabled_ramp": "(장애인) 경사로 안내 표지판", "sign_disabled_callbell": "(장애인) 비상 호출벨 안내표지판",
                              "sign_disabled_icon": "장애인 아이콘 표시",
                              "braille_sign": "표지판 내 점자 영역 ",
                              "chair_multi": "다인용 평의자", "chair_one": "일인용 의자", "chair_circular": "원형 의자",
                              "chair_back": "등받이가 있는 휴게 의자",
                              "chair_handle": "손잡이가 있는 휴게 의자",
                              "number_ticket_machine": "번호표",
                              "beverage_vending_machine": "판매기",
                              "beverage_desk": "음료대",
                              "trash_can": "휴지통",
                              "mailbox": "우체통"}

    @staticmethod
    def load_image_file(filename):
        try:
            image_pil = PIL.Image.open(filename)
        except IOError:
            logger.error("Failed opening image file: {}".format(filename))
            return

        # apply orientation to image according to exif
        image_pil = utils.apply_exif_orientation(image_pil)

        with io.BytesIO() as f:
            ext = osp.splitext(filename)[1].lower()
            if PY2 and QT4:
                format = "PNG"
            elif ext in [".jpg", ".jpeg"]:
                format = "JPEG"
            else:
                format = "PNG"
            image_pil.save(f, format=format)
            f.seek(0)
            return f.read()

    def load(self, filename):
        keys = [
            "version",
            "imageData",
            "imagePath",
            "shapes",  # polygonal annotations
            "flags",  # image level flags
            "imageHeight",
            "imageWidth",
        ]
        shape_keys = [
            "label",
            "points",
            "group_id",
            "shape_type",
            "flags",
        ]
        try:

            shape_eng_to_kor_dict = {
                "flatness_A": "flatness_A(평탄성_A)", "flatness_B": "flatness_B(평탄성_B)", "flatness_C": "flatness_C(평탄성_C)",
                "flatness_D": "flatness_D(평탄성_D)", "flatness_E": "flatness_E(평탄성_E)",
                "walkway_paved": "walkway_paved(포장도로)", "walkway_block": "walkway_block(보도블럭)",
                "paved_state_broken": "paved_state_broken(포장도로 파손)", "paved_state_normal": "paved_state_normal(포장도로 정상)",
                "block_state_broken": "block_state_broken(보도블럭 파손)", "block_state_normal": "block_state_normal(보도블럭 정상)",
                "block_kind_bad": "block_kind_bad(주행성 나쁨)", "block_kind_good": "block_kind_good(주행성 좋음)",
                "outcurb_rectangle": "outcurb_rectangle(사각모서리 연석 정상)", "outcurb_slide": "outcurb_slide(경사형 연석 정상)",
                "outcurb_rectangle_broken": "outcurb_rectangle_broken(사각모서리 연석 파손)", "outcurb_slide_broken": "outcurb_slide_broken(경사형 연석 파손)",
                "restspace": "restspace(휴식참)", "sidegap_in": "sidegap_in(문턱 (실내))", "sidegap_out": "sidegap_out(문턱 (실외))",
                "sewer_cross": "sewer_cross(격자형 배수구)", "sewer_line": "sewer_line(비 격자형 배수구)",
                "brailleblock_dot": "brailleblock_dot(점형블록)", "brailleblock_line": "brailleblock_line(선형블록)",
                "brailleblock_dot_broken": "brailleblock_dot_broken(점형블록 파손)", "brailleblock_line_broken": "brailleblock_line_broken(선형블록 파손)",
                "continuity_tree": "continuity_tree(연속하지 않음 (가로수영역))", "continuity_manhole": "continuity_manhole(연속하지 않음 (맨홀))",
                "ramp_yes": "ramp_yes(미끄럼방지 있는 경사로)", "ramp_no": "ramp_no(미끄럼방지 없는 경사로)",
                "bicycleroad_broken": "bicycleroad_broken(자전거 도로 파손)", "bicycleroad_normal": "bicycleroad_normal(자전거 도로 정상)",
                "planecrosswalk_broken": "planecrosswalk_broken(평면횡단보도 파손)", "planecrosswalk_normal": "planecrosswalk_normal(평면횡단보도 정상)",
                "steepramp": "steepramp(간이 부분경사로)", "bump_slow": "bump_slow(과속방지턱)", "bump_zigzag": "bump_zigzag(지그재크형 도로)",
                "weed": "weed(잡초)", "floor_normal": "floor_normal(복도 바닥 정상)", "floor_broken": "floor_broken(복도바닥 파손)",
                "flowerbed": "flowerbed(화단)", "parkspace": "parkspace(주차공간)", "tierbump": "tierbump(타이어 방지턱)",
                "stone": "stone(경관용 돌)", "enterrail": "enterrail(주출입문 레일)", "fireshutter": "fireshutter(방화셔터 바닥홈)",

                "stair_normal": "stair_normal(계단)", "stair_broken": "stair_broken(계단 파손)", "wall": "wall(벽)",
                "window_sliding": "window_sliding(미서기창)", "window_casement": "window_casement(여닫이창)",
                "pillar": "pillar(기둥)", "lift": "lift(승강기 (시설))", "door_normal": "door_normal(문)", "door_rotation": "door_rotation(회전문)", "lift_door": "lift_door(승강기 출입문)",
                "resting_place_roof": "resting_place_roof(휴게시설)", "reception_desk": "reception_desk(하부공간이 있는 접수대)",
                "protect_wall_protective": "protect_wall_protective(방호울타리)", "protect_wall_guardrail": "protect_wall_guardrail(접근방지용 난간)", "protect_wall_kickplate": "protect_wall_kickplate(킥플레이트)",
                "handle_vertical": "handle_vertical(수직막대형 손잡이)", "handle_lever": "handle_lever(레버형 손잡이)", "handle_circular": "handle_circular(원형손잡이)",
                "lift_button_normal": "lift_button_normal(일반(조작설비영역))", "lift_button_openarea": "lift_button_openarea(문열림닫침 영역)",
                "lift_button_layer": "lift_button_layer(층수영역)", "lift_button_emergency": "lift_button_emergency(비상벨영역)",
                "direction_sign_left": "direction_sign_left(왼쪽이동표식)", "direction_sign_right": "direction_sign_right(오른쪽이동표식)",
                "direction_sign_straight": "direction_sign_straight(화살표 (후진/직진 포함))", "direction_sign_exit": "direction_sign_exit(출구표식)",
                "sign_disabled_toilet": "sign_disabled_toilet((장애인) 화장실표시판)", "sign_disabled_parking": "sign_disabled_parking((장애인) 주차표지판)",
                "sign_disabled_elevator": "sign_disabled_elevator((장애인) 교통약자 전용 엘리베이터 표지판)", "sign_disabled_ramp": "sign_disabled_ramp((장애인) 경사로 안내 표지판)",
                "sign_disabled_callbell": "sign_disabled_callbell((장애인) 비상 호출벨 안내표지판)", "sign_disabled_icon": "sign_disabled_icon(장애인 아이콘 표시)",
                "braille_sign": "braille_sign(표지판 내 점자 영역)", "chair_multi": "chair_multi(다인용 평의자)", "chair_one": "chair_one(일인용 의자)", "chair_circular": "chair_circular(원형 의자)",
                "chair_back": "chair_back(등받이가 있는 휴게 의자)", "chair_handle": "chair_handle(손잡이가 있는 휴게 의자)",
                "number_ticket_machine": "number_ticket_machine(번호표)", "beverage_vending_machine": "beverage_vending_machine(판매기)", "beverage_desk": "beverage_desk(음료대)",
                "trash_can": "trash_can(휴지통)", "mailbox": "mailbox(우체통)"
            }

            with open(filename, "r") as f:
                data = json.load(f)

            # print("data : ", data)

            json_version = ""
            if data.get("version"):
                version = data.get("version")
                json_version = "old"
            else:
                common_info = data.get("info")
                version = common_info["version"]
                json_version = "new"

            # version = data.get("version")

            if version is None:
                logger.warn(
                    "Loading JSON file ({}) of unknown version".format(
                        filename
                    )
                )
            elif version.split(".")[0] != __version__.split(".")[0]:
                logger.warn(
                    "This JSON file ({}) may be incompatible with "
                    "current labelme. version in file: {}, "
                    "current version: {}".format(
                        filename, version, __version__
                    )
                )

            if json_version == "new":
                images_info = data.get("images")
                # image_data = images_info["imageData"]
                image_Path = images_info["file_name"]
                image_height = data.get("height")
                image_width = data.get("width")
                image_data = None
            else:
                # image_data = data["imageData"]
                image_Path = data["imagePath"]
                flags = data.get("flags") or {}
                image_height = data.get("imageHeight")
                image_width = data.get("imageWidth")
                image_data = None

            # if data["imageData"] is not None:
            if image_data is not None:
                # imageData = base64.b64decode(data["imageData"])
                imageData = base64.b64decode(image_data)
                if PY2 and QT4:
                    imageData = utils.img_data_to_png_data(imageData)
            else:
                # relative path from label file to relative path from cwd
                # imagePath = osp.join(osp.dirname(filename), data["imagePath"])
                # imagePath = osp.join(osp.dirname(filename), images_info["file_name"])
                import fnmatch
                is_true = fnmatch.fnmatch(image_Path, "*.jpg")
                if not is_true:
                    image_Path = image_Path + ".jpg"
                imagePath = osp.join(osp.dirname(filename), image_Path)


                imageData = self.load_image_file(imagePath)

            # flags = data.get("flags") or {}
            # imagePath = data["imagePath"]
            # imagePath = images_info["file_name"]
            imagePath = image_Path

            self._check_image_height_and_width(
                base64.b64encode(imageData).decode("utf-8"),
                image_height,
                image_width,
                # data.get("imageHeight"),
                # data.get("imageWidth"),
            )

            if json_version == "new":
                # annotations_info = data.get("annotations")
                shapes = [
                    dict(
                        label=shape_eng_to_kor_dict[s["category_id"]],
                        # points=s["points"],
                        points=s["segmentation"],
                        # shape_type=s.get("shape_type", "polygon"),
                        shape_type=s.get("id").split("_")[0],
                        # flags=s.get("flags", {}),
                        flags={},
                        # group_id=s.get("group_id"),
                        group_id=None,
                        other_data={
                            k: v for k, v in s.items() if k not in shape_keys
                        },
                    )
                    # for s in annotations_info["segmentation"]
                    for s in data["annotations"]
                ]
            else:
                shapes = [
                    dict(
                        label=shape_eng_to_kor_dict[s["label"]],
                        points=s["points"],
                        shape_type=s.get("shape_type", "polygon"),
                        flags=s.get("flags", {}),
                        group_id=s.get("group_id"),
                        other_data={
                            k: v for k, v in s.items() if k not in shape_keys
                        },
                    )
                    for s in data["shapes"]
                ]
            # shapes = [
            #     dict(
            #         label=s["label"],
            #         points=s["points"],
            #         shape_type=s.get("shape_type", "polygon"),
            #         flags=s.get("flags", {}),
            #         group_id=s.get("group_id"),
            #         other_data={
            #             k: v for k, v in s.items() if k not in shape_keys
            #         },
            #     )
            #     for s in data["shapes"]
            # ]

        except Exception as e:
            raise LabelFileError(e)

        otherData = {}
        for key, value in data.items():
            if key not in keys:
                otherData[key] = value

        # Only replace data after everything is loaded.
        if json_version == "new":
            self.flags = {}
        else:
            self.flags = flags

        # self.flags = flags
        self.shapes = shapes
        self.imagePath = imagePath
        self.imageData = imageData
        self.filename = filename
        self.otherData = otherData

    @staticmethod
    def _check_image_height_and_width(imageData, imageHeight, imageWidth):
        img_arr = utils.img_b64_to_arr(imageData)
        if imageHeight is not None and img_arr.shape[0] != imageHeight:
            logger.error(
                "imageHeight does not match with imageData or imagePath, "
                "so getting imageHeight from actual image."
            )
            imageHeight = img_arr.shape[0]
        if imageWidth is not None and img_arr.shape[1] != imageWidth:
            logger.error(
                "imageWidth does not match with imageData or imagePath, "
                "so getting imageWidth from actual image."
            )
            imageWidth = img_arr.shape[1]
        return imageHeight, imageWidth

    def save(
        self,
        filename,
        shapes,
        imagePath,
        imageHeight,
        imageWidth,
        Year,
        collector_id,
        image_date_captured,
        processing_id,
        imageData=None,
        otherData=None,
        flags=None,
    ):
        if imageData is not None:
            imageData = base64.b64encode(imageData).decode("utf-8")
            imageHeight, imageWidth = self._check_image_height_and_width(
                imageData, imageHeight, imageWidth
            )
        if otherData is None:
            otherData = {}
        if flags is None:
            flags = {}
        now = time.localtime()
        now_time = "%04d/%02d/%02d %02d:%02d:%02d" % (now.tm_year, now.tm_mon, now.tm_mday,
                                                      now.tm_hour, now.tm_min, now.tm_sec)

        annotations_format_ori = []
        category_format_ori = []
        rectangle_id = 0
        polygon_id = 0

        shape_kor_to_eng_dict = {
            "flatness_A(평탄성_A)": "flatness_A", "flatness_B(평탄성_B)": "flatness_B", "flatness_C(평탄성_C)": "flatness_C",
            "flatness_D(평탄성_D)": "flatness_D", "flatness_E(평탄성_E)": "flatness_E",
            "walkway_paved(포장도로)": "walkway_paved", "walkway_block(보도블럭)": "walkway_block",
            "paved_state_broken(포장도로 파손)": "paved_state_broken", "paved_state_normal(포장도로 정상)": "paved_state_normal",
            "block_state_broken(보도블럭 파손)": "block_state_broken", "block_state_normal(보도블럭 정상)": "block_state_normal",
            "block_kind_bad(주행성 나쁨)": "block_kind_bad", "block_kind_good(주행성 좋음)": "block_kind_good",
            "outcurb_rectangle(사각모서리 연석 정상)": "outcurb_rectangle", "outcurb_slide(경사형 연석 정상)": "outcurb_slide",
            "outcurb_rectangle_broken(사각모서리 연석 파손)": "outcurb_rectangle_broken", "outcurb_slide_broken(경사형 연석 파손)": "outcurb_slide_broken",
            "restspace(휴식참)": "restspace", "sidegap_in(문턱 (실내))": "sidegap_in", "sidegap_out(문턱 (실외))": "sidegap_out",
            "sewer_cross(격자형 배수구)": "sewer_cross", "sewer_line(비 격자형 배수구)": "sewer_line",
            "brailleblock_dot(점형블록)": "brailleblock_dot", "brailleblock_line(선형블록)": "brailleblock_line",
            "brailleblock_dot_broken(점형블록 파손)": "brailleblock_dot_broken", "brailleblock_line_broken(선형블록 파손)": "brailleblock_line_broken",
            "continuity_tree(연속하지 않음 (가로수영역))": "continuity_tree", "continuity_manhole(연속하지 않음 (맨홀))": "continuity_manhole",
            "ramp_yes(미끄럼방지 있는 경사로)": "ramp_yes", "ramp_no(미끄럼방지 없는 경사로)": "ramp_no",
            "bicycleroad_broken(자전거 도로 파손)": "bicycleroad_broken", "bicycleroad_normal(자전거 도로 정상)": "bicycleroad_normal",
            "planecrosswalk_broken(평면횡단보도 파손)": "planecrosswalk_broken", "planecrosswalk_normal(평면횡단보도 정상)": "planecrosswalk_normal",
            "steepramp(간이 부분경사로)": "steepramp", "bump_slow(과속방지턱)": "bump_slow", "bump_zigzag(지그재크형 도로)": "bump_zigzag",
            "weed(잡초)": "weed", "floor_normal(복도 바닥 정상)": "floor_normal", "floor_broken(복도바닥 파손)": "floor_broken",
            "flowerbed(화단)": "flowerbed", "parkspace(주차공간)": "parkspace", "tierbump(타이어 방지턱)": "tierbump",
            "stone(경관용 돌)": "stone", "enterrail(주출입문 레일)": "enterrail", "fireshutter(방화셔터 바닥홈)": "fireshutter",

            "stair_normal(계단)": "stair_normal", "stair_broken(계단 파손)": "stair_broken", "wall(벽)": "wall",
            "window_sliding(미서기창)": "window_sliding", "window_casement(여닫이창)": "window_casement",
            "pillar(기둥)": "pillar", "lift(승강기 (시설))": "lift", "door_normal(문)": "door_normal", "door_rotation(회전문)": "door_rotation",
            "lift_door(승강기 출입문)": "lift_door", "resting_place_roof(휴게시설)": "resting_place_roof", "reception_desk(하부공간이 있는 접수대)": "reception_desk",
            "protect_wall_protective(방호울타리)": "protect_wall_protective", "protect_wall_guardrail(접근방지용 난간)": "protect_wall_guardrail", "protect_wall_kickplate(킥플레이트)": "protect_wall_kickplate",
            "handle_vertical(수직막대형 손잡이)": "handle_vertical", "handle_lever(레버형 손잡이)": "handle_lever", "handle_circular(원형손잡이)": "handle_circular",
            "lift_button_normal(일반(조작설비영역))": "lift_button_normal", "lift_button_openarea(문열림닫침 영역)": "lift_button_openarea",
            "lift_button_layer(층수영역)": "lift_button_layer", "lift_button_emergency(비상벨영역)": "lift_button_emergency",
            "direction_sign_left(왼쪽이동표식)": "direction_sign_left", "direction_sign_right(오른쪽이동표식)": "direction_sign_right",
            "direction_sign_straight(화살표 (후진/직진 포함))": "direction_sign_straight", "direction_sign_exit(출구표식)": "direction_sign_exit",
            "sign_disabled_toilet((장애인) 화장실표시판)": "sign_disabled_toilet", "sign_disabled_parking((장애인) 주차표지판)": "sign_disabled_parking",
            "sign_disabled_elevator((장애인) 교통약자 전용 엘리베이터 표지판)": "sign_disabled_elevator", "sign_disabled_ramp((장애인) 경사로 안내 표지판)": "sign_disabled_ramp",
            "sign_disabled_callbell((장애인) 비상 호출벨 안내표지판)": "sign_disabled_callbell", "sign_disabled_icon(장애인 아이콘 표시)": "sign_disabled_icon",
            "braille_sign(표지판 내 점자 영역)": "braille_sign", "chair_multi(다인용 평의자)": "chair_multi", "chair_one(일인용 의자)": "chair_one", "chair_circular(원형 의자)": "chair_circular",
            "chair_back(등받이가 있는 휴게 의자)": "chair_back", "chair_handle(손잡이가 있는 휴게 의자)": "chair_handle",
            "number_ticket_machine(번호표)": "number_ticket_machine", "beverage_vending_machine(판매기)": "beverage_vending_machine",
            "beverage_desk(음료대)": "beverage_desk", "trash_can(휴지통)": "trash_can", "mailbox(우체통)": "mailbox"
        }

        for i in range(len(shapes)):
            bbox = []
            segmentation = []
            object_id = ""
            shape_type = shapes[i]["shape_type"]

            if shape_type == "rectangle":
                # bbox = shapes[i]["points"]
                segmentation = shapes[i]["points"]
                rectangle_id = rectangle_id + 1
                object_id = "rectangle_" + str(rectangle_id)
            else:
                segmentation = shapes[i]["points"]
                polygon_id = polygon_id + 1
                object_id = "polygon_" + str(polygon_id)
            annotations_format = {
                "id": object_id,
                # "image_id": image_id,
                "processor_id": processing_id,
                # "category_id": shapes[i]["label"],
                "category_id": shape_kor_to_eng_dict[shapes[i]["label"]],
                "segmentation": segmentation,
                # "area": "area",
                # "bbox": bbox,
                # "iscrowd": None,
                # "keypoints": "keypoints",
                # "num_keypoints": "num_keypoints"
            }

            super_category = []
            if shape_kor_to_eng_dict[shapes[i]["label"]] in self.supercategory:
                # print("label == supercategory")
                super_category = shape_kor_to_eng_dict[shapes[i]["label"]]
                # print(shapes[i]["label"], super_category)
            else:
                # print("label != supercategory")
                text = shape_kor_to_eng_dict[shapes[i]["label"]]
                list_a = text.split("_")
                if len(list_a) == 3:
                    # print("len(list_a) : ", len(list_a))
                    if list_a[0] + "_" + list_a[1] in self.supercategory:
                        super_category = list_a[0] + "_" + list_a[1]
                    elif list_a[0] in self.supercategory:
                        super_category = list_a[0]
                elif len(list_a) == 2:
                    # print("len(list_a) : ", len(list_a))
                    # print("list_a[0] : ", list_a[0])
                    if list_a[0] in self.supercategory:
                        super_category = list_a[0]
            # print("shape[i]['label'] :", shapes[i]["label"])
            # print("super_category : ", super_category)

            category_name = ""
            if shape_kor_to_eng_dict[shapes[i]["label"]] in self.category_name.keys():
                key = shape_kor_to_eng_dict[shapes[i]["label"]]
                category_name = self.category_name[key]
            category_format = {
                # "id": "category_id",
                "id": shape_kor_to_eng_dict[shapes[i]["label"]],
                # "name": shapes[i]["label"],
                "name": category_name,
                "supercategory": super_category,
                # "keypoints": "keypoints",
                # "num_keypoints": "num_keypoints"
            }
            annotations_format_ori.append(annotations_format)
            category_format_ori.append(category_format)


        json_format = {
            "info": {
                "Year": Year,
                # "description": description,
                # "url": "url",
                "version": __version__,
                # "contributor": "wkentaro",
                "date_created": now_time,
            },
            # "licenses": {
            #     "id": "license id",
            #     "url": "license url",
            #     "name": "wkentaro",
            # },
            "images": {
                # "license": "license number",
                "file_name": imagePath,
                "height": imageHeight,
                "width": imageWidth,
                "date_captured": image_date_captured,
                "collector_id": collector_id,
                # "imageData": imageData,
            },
            "annotations": annotations_format_ori,
            "category": category_format_ori


            # "annotations":{
            #     "id": "object id",              # ???????????????
            #     "image_id": image_id,
            #     "category_id": "category_id",   # all ?????
            #     "segmentation": shapes,
            #     "area": "area",
            #     "bbox": bbox,
            #     "iscrowd": iscrowd,
            #     "keypoints(optional)": "keypoints",
            #     "num_keypoints(optional)": "num_keypoints",
            # },
            # "categories":{
            #     "id": "category_id",
            #     "name": "category_name",
            #     "supercategory": "supercategory",
            #     "keypoints(optional)": "keypoints",
            #     "num_keypoints(optional)": "num_keypoints",
            # }

        }
        data = json_format

        # data = dict(
        #     version=__version__,
        #     flags=flags,
        #     shapes=shapes,
        #     imagePath=imagePath,
        #     imageData=imageData,
        #     imageHeight=imageHeight,
        #     imageWidth=imageWidth,
        # )
        # for key, value in otherData.items():
        #     print("key : ", key)
        #     print("value : ", value)
        #     assert key not in data
        #     data[key] = value
        try:
            with open(filename, "w") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            self.filename = filename

        except Exception as e:
            raise LabelFileError(e)

    @staticmethod
    def is_label_file(filename):
        return osp.splitext(filename)[1].lower() == LabelFile.suffix
