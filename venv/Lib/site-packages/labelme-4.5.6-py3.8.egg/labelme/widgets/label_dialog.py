import re

from qtpy import QT_VERSION
from qtpy import QtCore
from qtpy import QtGui
from qtpy import QtWidgets

from labelme.logger import logger
import labelme.utils

QT5 = QT_VERSION[0] == "5"


# TODO(unknown):
# - Calculate optimal position so as not to go out of screen area.


class LabelQLineEdit(QtWidgets.QLineEdit):
    def setListWidget(self, list_widget):
        self.list_widget = list_widget

    def keyPressEvent(self, e):
        if e.key() in [QtCore.Qt.Key_Up, QtCore.Qt.Key_Down]:
            self.list_widget.keyPressEvent(e)
        else:
            super(LabelQLineEdit, self).keyPressEvent(e)


class LabelDialog(QtWidgets.QDialog):

    def __init__(
            self,
            text="Enter object label",
            parent=None,
            labels=None,
            sort_labels=True,
            show_text_field=True,
            completion="startswith",
            fit_to_content=None,
            flags=None,
    ):
        if fit_to_content is None:
            fit_to_content = {"row": False, "column": True}
        self._fit_to_content = fit_to_content

        super(LabelDialog, self).__init__(parent)
        self.combobox_first = QtWidgets.QComboBox()
        combobox_first_items = ["road(노면)", "space(공간)"]
        self.combobox_first.addItems(combobox_first_items)
        self.combobox_first.currentTextChanged.connect(self.changedComboboxFirst)

        self.combobox_second = QtWidgets.QComboBox()
        combobox_second_items = ["flatness(평탄성)", "walkway(보행로(보도)의 재질)", "paved_state(포장도로 상태)", "block_state(보도블럭 상태)", "block_kind(보도블럭 종류)",
                                 "outcurb(돌출형 연석)", "restspace(휴식참)", "sidegap(턱)", "sewer(배수구 덮개)", "brailleblock(점자블록)", "continuity(연속성)", "ramp(경사로)",
                                 "bicycleroad(자전거 도로)", "planecrosswalk(평면횡단보도)", "bump(속도저감시설)", "weed(잡초)", "floor(복도 바닥)",
                                 "flowerbed(화단)", "parkspace(주차공간)", "enterrail(주출입문 레일)", "fireshutter(방화셔터 바닥홈)"]
        self.combobox_second.addItems(combobox_second_items)
        self.combobox_second.currentTextChanged.connect(self.changedComboboxSecond)

        self.combobox_third = QtWidgets.QComboBox()
        combobox_third_items = ["flatness_A(평탄성_A)", "flatness_B(평탄성_B)", "flatness_C(평탄성_C)", "flatness_D(평탄성_D)", "flatness_E(평탄성_E)"]
        self.combobox_third.addItems(combobox_third_items)
        self.combobox_third.currentTextChanged.connect(self.changedCombobox)

        self.edit = LabelQLineEdit()


        # TRUE OR FALSE
        # self.edit.setReadOnly(True)


        self.edit.setPlaceholderText(text)
        self.edit.setValidator(labelme.utils.labelValidator())
        self.edit.editingFinished.connect(self.postProcess)
        if flags:
            self.edit.textChanged.connect(self.updateFlags)
        self.edit_group_id = QtWidgets.QLineEdit()
        self.edit_group_id.setPlaceholderText("Group ID")
        self.edit_group_id.setValidator(
            QtGui.QRegExpValidator(QtCore.QRegExp(r"\d*"), None)
        )
        layout = QtWidgets.QVBoxLayout()
        self.setFixedWidth(700)
        if show_text_field:
            layout_edit = QtWidgets.QHBoxLayout()
            layout_edit.addWidget(self.edit, 6)
            layout_edit.addWidget(self.edit_group_id, 2)
            layout_edit2 = QtWidgets.QHBoxLayout()
            layout_edit2.addWidget(self.combobox_first, 2)
            layout_edit2.addWidget(self.combobox_second, 3)
            layout_edit2.addWidget(self.combobox_third, 3)
            layout.addLayout(layout_edit)
            layout.addLayout(layout_edit2)
        # buttons
        self.buttonBox = bb = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel,
            QtCore.Qt.Horizontal,
            self,
            )
        bb.button(bb.Ok).setIcon(labelme.utils.newIcon("done"))
        bb.button(bb.Cancel).setIcon(labelme.utils.newIcon("undo"))
        bb.accepted.connect(self.validate)
        bb.rejected.connect(self.reject)
        layout.addWidget(bb)
        # label_list
        self.labelList = QtWidgets.QListWidget()
        if self._fit_to_content["row"]:
            self.labelList.setHorizontalScrollBarPolicy(
                QtCore.Qt.ScrollBarAlwaysOff
            )
        if self._fit_to_content["column"]:
            self.labelList.setVerticalScrollBarPolicy(
                QtCore.Qt.ScrollBarAlwaysOff
            )
        self._sort_labels = sort_labels
        if labels:
            self.labelList.addItems(labels)
        if self._sort_labels:
            self.labelList.sortItems()
        else:
            self.labelList.setDragDropMode(
                QtWidgets.QAbstractItemView.InternalMove
            )
        self.labelList.currentItemChanged.connect(self.labelSelected)
        self.labelList.itemDoubleClicked.connect(self.labelDoubleClicked)
        self.edit.setListWidget(self.labelList)
        layout.addWidget(self.labelList)
        # label_flags
        if flags is None:
            flags = {}
        self._flags = flags
        self.flagsLayout = QtWidgets.QVBoxLayout()
        self.resetFlags()
        layout.addItem(self.flagsLayout)
        self.edit.textChanged.connect(self.updateFlags)
        self.setLayout(layout)
        # completion
        completer = QtWidgets.QCompleter()
        if not QT5 and completion != "startswith":
            logger.warn(
                "completion other than 'startswith' is only "
                "supported with Qt5. Using 'startswith'"
            )
            completion = "startswith"
        if completion == "startswith":
            completer.setCompletionMode(QtWidgets.QCompleter.InlineCompletion)
            # Default settings.
            # completer.setFilterMode(QtCore.Qt.MatchStartsWith)
        elif completion == "contains":
            completer.setCompletionMode(QtWidgets.QCompleter.PopupCompletion)
            completer.setFilterMode(QtCore.Qt.MatchContains)
        else:
            raise ValueError("Unsupported completion: {}".format(completion))
        completer.setModel(self.labelList.model())
        self.edit.setCompleter(completer)

        self.polygon_text_items = ["flatness_A(평탄성_A)", "flatness_B(평탄성_B)", "flatness_C(평탄성_C)",
                                   "flatness_D(평탄성_D)", "flatness_E(평탄성_E)",
                                   "walkway_paved(포장도로)", "walkway_block(보도블럭)", "paved_state_broken(포장도로 파손)", "paved_state_normal(포장도로 정상)",
                                   "block_state_broken(보도블럭 파손)", "block_state_normal(보도블럭 정상)", "block_kind_bad(주행성 나쁨)", "block_kind_good(주행성 좋음)",
                                   "outcurb_rectangle(사각모서리 연석 정상)", "outcurb_slide(경사형 연석 정상)",
                                   "outcurb_rectangle_broken(사각모서리 연석 파손)", "outcurb_slide_broken(경사형 연석 파손)",
                                   "restspace(휴식참)", "sidegap_in(문턱 (실내))", "sidegap_out(문턱 (실외))", "sewer_cross(격자형 배수구)", "sewer_line(비 격자형 배수구)",
                                   "brailleblock_dot(점형블록)", "brailleblock_line(선형블록)", "brailleblock_dot_broken(점형블록 파손)", "brailleblock_line_broken(선형블록 파손)",
                                   "continuity_tree(연속하지 않음 (가로수영역))", "continuity_manhole(연속하지 않음 (맨홀))",
                                   "ramp_yes(미끄럼방지 있는 경사로)", "ramp_no(미끄럼방지 없는 경사로)",
                                   "bicycleroad_broken(자전거 도로 파손)", "bicycleroad_normal(자전거 도로 정상)",
                                   "planecrosswalk_broken(평면횡단보도 파손)", "planecrosswalk_normal(평면횡단보도 정상)",
                                   "bump_slow(과속방지턱)", "bump_zigzag(지그재크형 도로)", "weed(잡초)", "floor_normal(복도 바닥 정상)", "floor_broken(복도바닥 파손)",
                                   "flowerbed(화단)", "parkspace(주차공간)", "enterrail(주출입문 레일)", "fireshutter(방화셔터 바닥홈)",
                                   "stair_normal(계단)", "stair_broken(계단 파손)", "wall(벽)", "resting_place_roof(휴게시설)", "reception_desk(하부공간이 있는 접수대)",
                                   "lift_button_normal(일반(조작설비영역))", "lift_button_openarea(문열림닫침 영역)", "lift_button_layer(층수영역)", "lift_button_emergency(비상벨영역)"]

        self.rectangle_text_items = ["sewer_cross(격자형 배수구)", "sewer_line(비 격자형 배수구)", "steepramp(간이 부분경사로)",
                                     "tierbump(타이어 방지턱)", "stone(경관용 돌)", "window_sliding(미서기창)", "window_casement(여닫이창)",
                                     "pillar(기둥)", "lift(승강기 (시설))", "door_normal(문)", "door_rotation(회전문)", "lift_door(승강기 출입문)",
                                     "protect_wall_protective(방호울타리)", "protect_wall_guardrail(접근방지용 난간)", "protect_wall_kickplate(킥플레이트)",
                                     "handle_vertical(수직막대형 손잡이)", "handle_lever(레버형 손잡이)", "handle_circular(원형손잡이)",
                                     "lift_button_normal(일반(조작설비영역))", "lift_button_openarea(문열림닫침 영역)", "lift_button_layer(층수영역)", "lift_button_emergency(비상벨영역)",
                                     "direction_sign_left(왼쪽이동표식)", "direction_sign_right(오른쪽이동표식)",
                                     "direction_sign_straight(화살표 (후진/직진 포함))", "direction_sign_exit(출구표식)",
                                     "sign_disabled_toilet((장애인) 화장실표시판)", "sign_disabled_parking((장애인) 주차표지판)", "sign_disabled_elevator((장애인) 교통약자 전용 엘리베이터 표지판)",
                                     "sign_disabled_ramp((장애인) 경사로 안내 표지판)", "sign_disabled_callbell((장애인) 비상 호출벨 안내표지판)", "sign_disabled_icon(장애인 아이콘 표시)",
                                     "braille_sign(표지판 내 점자 영역)", "chair_multi(다인용 평의자)", "chair_one(일인용 의자)", "chair_circular(원형 의자)",
                                     "chair_back(등받이가 있는 휴게 의자)", "chair_handle(손잡이가 있는 휴게 의자)", "number_ticket_machine(번호표)", "beverage_vending_machine(판매기)",
                                     "beverage_desk(음료대)", "trash_can(휴지통)", "mailbox(우체통)"]


    def changedComboboxFirst(self, value):
        self.combobox_second.clear()
        combobox_second_items = []

        if value == "road(노면)":
            if self.createMode == "polygon":
                # combobox_second_items = ["flatness", "walkway",
                #                          "paved_state", "block_state",
                #                          "block_kind", "outcurb", "restspace",
                #                          "sidegap", "sewer", "brailleblock",
                #                          "continuity", "ramp", "bicycleroad",
                #                          "planecrosswalk", "bump", "weed",
                #                          "floor", "flowerbed", "parkspace",
                #                          "enterrail", "fireshutter"]
                combobox_second_items =["flatness(평탄성)", "walkway(보행로(보도)의 재질)", "paved_state(포장도로 상태)", "block_state(보도블럭 상태)", "block_kind(보도블럭 종류)",
                                 "outcurb(돌출형 연석)", "restspace(휴식참)", "sidegap(턱)", "sewer(배수구 덮개)", "brailleblock(점자블록)", "continuity(연속성)", "ramp(경사로)",
                                 "bicycleroad(자전거 도로)", "planecrosswalk(평면횡단보도)", "bump(속도저감시설)", "weed(잡초)", "floor(복도 바닥)",
                                 "flowerbed(화단)", "parkspace(주차공간)", "enterrail(주출입문 레일)", "fireshutter(방화셔터 바닥홈)"]
            elif self.createMode == "rectangle":
                combobox_second_items = ["sewer(배수구 덮개)", "steepramp(부분경사로)", "tierbump(타이어 방지턱)", "stone(경관용 돌)"]

        elif value == "space(공간)":
            if self.createMode == "polygon":
                combobox_second_items = ["stair(계단)", "stair_broken(계단-파손)", "wall(벽)",
                                         "resting_place_roof(휴게시설-지붕)", "reception_desk(접수대)", "lift_button(승강기이용자 조작설비)"]

            elif self.createMode == "rectangle":
                combobox_second_items = ["window(창문)", "pillar(기둥)",
                                         "lift(승강기 (시설))", "door(출입문의 형태)", "lift_door(승강기 출입문)",
                                         "protect_wall(보호벽)", "handle(손잡이)",
                                         "lift_button(승강기이용자 조작설비)", "direction_sign(통행방향표식)",
                                         "sign_disabled(안내표지판)", "braille_sign(점자표지판)",
                                         "chair(휴게의자)", "chair_back(휴게의자-등받이)", "chair_handle(휴게의자-손잡이)",
                                         "number_ticket_machine(번호표)", "beverage_vending_machine(판매기)",
                                         "beverage_desk(음료대)", "trash_can(휴지통)", "mailbox(우체통)"]

        self.combobox_second.addItems(combobox_second_items)

    def changedComboboxSecond(self, value):
        self.combobox_third.clear()
        combobox_third_items = []


        if value == "flatness(평탄성)":
            combobox_third_items = ["flatness_A(평탄성_A)", "flatness_B(평탄성_B)", "flatness_C(평탄성_C)", "flatness_D(평탄성_D)", "flatness_E(평탄성_E)"]
        elif value == "walkway(보행로(보도)의 재질)":
            combobox_third_items = ["walkway_paved(포장도로)", "walkway_block(보도블럭)"]
        elif value == "paved_state(포장도로 상태)":
            combobox_third_items = ["paved_state_broken(포장도로 파손)", "paved_state_normal(포장도로 정상)"]
        elif value == "block_state(보도블럭 상태)":
            combobox_third_items = ["block_state_broken(보도블럭 파손)", "block_state_normal(보도블럭 정상)"]
        elif value == "block_kind(보도블럭 종류)":
            combobox_third_items = ["block_kind_bad(주행성 나쁨)", "block_kind_good(주행성 좋음)"]
        elif value == "outcurb(돌출형 연석)":
            combobox_third_items = ["outcurb_rectangle(사각모서리 연석 정상)", "outcurb_slide(경사형 연석 정상)",
                                    "outcurb_rectangle_broken(사각모서리 연석 파손)", "outcurb_slide_broken(경사형 연석 파손)"]
        elif value == "restspace(휴식참)":
            combobox_third_items = ["restspace(휴식참)"]
        elif value == "sidegap(턱)":
            combobox_third_items = ["sidegap_in(문턱 (실내))", "sidegap_out(문턱 (실외))"]
        elif value == "sewer(배수구 덮개)":
            combobox_third_items = ["sewer_cross(격자형 배수구)", "sewer_line(비 격자형 배수구)"]
        elif value == "brailleblock(점자블록)":
            combobox_third_items = ["brailleblock_dot(점형블록)", "brailleblock_line(선형블록)",
                                    "brailleblock_dot_broken(점형블록 파손)", "brailleblock_line_broken(선형블록 파손)"]
        elif value == "continuity(연속성)":
            combobox_third_items = ["continuity_tree(연속하지 않음 (가로수영역))", "continuity_manhole(연속하지 않음 (맨홀))"]
        elif value == "ramp(경사로)":
            combobox_third_items = ["ramp_yes(미끄럼방지 있는 경사로)", "ramp_no(미끄럼방지 없는 경사로)"]
        elif value == "bicycleroad(자전거 도로)":
            combobox_third_items = ["bicycleroad_broken(자전거 도로 파손)", "bicycleroad_normal(자전거 도로 정상)"]
        elif value == "planecrosswalk(평면횡단보도)":
            combobox_third_items = ["planecrosswalk_broken(평면횡단보도 파손)", "planecrosswalk_normal(평면횡단보도 정상)"]
        elif value == "steepramp(부분경사로)":
            combobox_third_items = ["steepramp(간이 부분경사로)"]
        elif value == "bump(속도저감시설)":
            combobox_third_items = ["bump_slow(과속방지턱)", "bump_zigzag(지그재크형 도로)"]
        elif value == "weed(잡초)":
            combobox_third_items = ["weed(잡초)"]
        elif value == "floor(복도 바닥)":
            combobox_third_items = ["floor_normal(복도 바닥 정상)", "floor_broken(복도바닥 파손)"]
        elif value == "flowerbed(화단)":
            combobox_third_items = ["flowerbed(화단)"]
        elif value == "parkspace(주차공간)":
            combobox_third_items = ["parkspace(주차공간)"]
        elif value == "tierbump(타이어 방지턱)":
            combobox_third_items = ["tierbump(타이어 방지턱)"]
        elif value == "stone(경관용 돌)":
            combobox_third_items = ["stone(경관용 돌)"]
        elif value == "enterrail(주출입문 레일)":
            combobox_third_items = ["enterrail(주출입문 레일)"]
        elif value == "fireshutter(방화셔터 바닥홈)":
            combobox_third_items = ["fireshutter(방화셔터 바닥홈)"]

        elif value == "stair(계단)":
            combobox_third_items = ["stair_normal(계단)"]
        elif value == "stair_broken(계단-파손)":
            combobox_third_items = ["stair_broken(계단 파손)"]
        elif value == "wall(벽)":
            combobox_third_items = ["wall(벽)"]
        elif value == "window(창문)":
            combobox_third_items = ["window_sliding(미서기창)", "window_casement(여닫이창)"]
        elif value == "pillar(기둥)":
            combobox_third_items = ["pillar(기둥)"]
        elif value == "lift(승강기 (시설))":
            combobox_third_items = ["lift(승강기 (시설))"]
        elif value == "door(출입문의 형태)":
            combobox_third_items = ["door_normal(문)", "door_rotation(회전문)"]
        elif value == "lift_door(승강기 출입문)":
            combobox_third_items = ["lift_door(승강기 출입문)"]
        elif value == "resting_place_roof(휴게시설-지붕)":
            combobox_third_items = ["resting_place_roof(휴게시설)"]
        elif value == "reception_desk(접수대)":
            combobox_third_items = ["reception_desk(하부공간이 있는 접수대)"]
        elif value == "protect_wall(보호벽)":
            combobox_third_items = ["protect_wall_protective(방호울타리)", "protect_wall_guardrail(접근방지용 난간)",
                                    "protect_wall_kickplate(킥플레이트)"]
        elif value == "handle(손잡이)":
            combobox_third_items = ["handle_vertical(수직막대형 손잡이)", "handle_lever(레버형 손잡이)", "handle_circular(원형손잡이)"]
        elif value == "lift_button(승강기이용자 조작설비)":
            combobox_third_items = ["lift_button_normal(일반(조작설비영역))", "lift_button_openarea(문열림닫침 영역)",
                                    "lift_button_layer(층수영역)", "lift_button_emergency(비상벨영역)"]
        elif value == "direction_sign(통행방향표식)":
            combobox_third_items = ["direction_sign_left(왼쪽이동표식)", "direction_sign_right(오른쪽이동표식)",
                                    "direction_sign_straight(화살표 (후진/직진 포함))", "direction_sign_exit(출구표식)"]
        elif value == "sign_disabled(안내표지판)":
            combobox_third_items = ["sign_disabled_toilet((장애인) 화장실표시판)", "sign_disabled_parking((장애인) 주차표지판)",
                                    "sign_disabled_elevator((장애인) 교통약자 전용 엘리베이터 표지판)", "sign_disabled_ramp((장애인) 경사로 안내 표지판)",
                                    "sign_disabled_callbell((장애인) 비상 호출벨 안내표지판)", "sign_disabled_icon(장애인 아이콘 표시)"]
        elif value == "braille_sign(점자표지판)":
            combobox_third_items = ["braille_sign(표지판 내 점자 영역)"]
        elif value == "chair(휴게의자)":
            combobox_third_items = ["chair_multi(다인용 평의자)", "chair_one(일인용 의자)", "chair_circular(원형 의자)"]
        elif value == "chair_back(휴게의자-등받이)":
            combobox_third_items = ["chair_back(등받이가 있는 휴게 의자)"]
        elif value == "chair_handle(휴게의자-손잡이)":
            combobox_third_items = ["chair_handle(손잡이가 있는 휴게 의자)"]
        elif value == "number_ticket_machine(번호표)":
            combobox_third_items = ["number_ticket_machine(번호표)"]
        elif value == "beverage_vending_machine(판매기)":
            combobox_third_items = ["beverage_vending_machine(판매기)"]
        elif value == "beverage_desk(음료대)":
            combobox_third_items = ["beverage_desk(음료대)"]
        elif value == "trash_can(휴지통)":
            combobox_third_items = ["trash_can(휴지통)"]
        elif value == "mailbox(우체통)":
            combobox_third_items = ["mailbox(우체통)"]

        self.combobox_third.addItems(combobox_third_items)

    def changedCombobox(self, value):
        self.edit.setText(value)

    def addLabelHistory(self, label):
        if self.labelList.findItems(label, QtCore.Qt.MatchExactly):
            return
        self.labelList.addItem(label)
        if self._sort_labels:
            self.labelList.sortItems()

    def labelSelected(self, item):
        self.edit.setText(item.text())

    def validate(self):
        text = self.edit.text()
        if hasattr(text, "strip"):
            text = text.strip()
        else:
            text = text.trimmed()

        # if text in self.text_items:
        #     self.accept()
        # else:
        #     mb = QtWidgets.QMessageBox
        #     msg = self.tr("Wrong word !! Check your word please")
        #     answer = mb.warning(self, self.tr("Warning"), msg, mb.Yes)
        if self.createMode == "polygon":
            if text in self.polygon_text_items:
                self.accept()
            else:
                mb = QtWidgets.QMessageBox
                msg = self.tr("Wrong word !! Check your word please")
                answer = mb.warning(self, self.tr("Warning"), msg, mb.Yes)
                if answer == mb.Yes:
                    return
        elif self.createMode == "rectangle":
            if text in self.rectangle_text_items:
                self.accept()
            else:
                mb = QtWidgets.QMessageBox
                msg = self.tr("Wrong word !! Check your word please")
                answer = mb.warning(self, self.tr("Warning"), msg, mb.Yes)
                if answer == mb.Yes:
                    return
        # if text:
        #     self.accept()

    def labelDoubleClicked(self, item):
        self.validate()

    def postProcess(self):
        text = self.edit.text()
        if hasattr(text, "strip"):
            text = text.strip()
        else:
            text = text.trimmed()
        self.edit.setText(text)

    def updateFlags(self, label_new):
        # keep state of shared flags
        flags_old = self.getFlags()

        flags_new = {}
        for pattern, keys in self._flags.items():
            if re.match(pattern, label_new):
                for key in keys:
                    flags_new[key] = flags_old.get(key, False)
        self.setFlags(flags_new)

    def deleteFlags(self):
        for i in reversed(range(self.flagsLayout.count())):
            item = self.flagsLayout.itemAt(i).widget()
            self.flagsLayout.removeWidget(item)
            item.setParent(None)

    def resetFlags(self, label=""):
        flags = {}
        for pattern, keys in self._flags.items():
            if re.match(pattern, label):
                for key in keys:
                    flags[key] = False
        self.setFlags(flags)

    def setFlags(self, flags):
        self.deleteFlags()
        for key in flags:
            item = QtWidgets.QCheckBox(key, self)
            item.setChecked(flags[key])
            self.flagsLayout.addWidget(item)
            item.show()

    def getFlags(self):
        flags = {}
        for i in range(self.flagsLayout.count()):
            item = self.flagsLayout.itemAt(i).widget()
            flags[item.text()] = item.isChecked()
        return flags

    def getGroupId(self):
        group_id = self.edit_group_id.text()
        if group_id:
            return int(group_id)
        return None

    def popUp(self, text=None, move=True, flags=None, group_id=None, createMode=None, edit_flags=None,
              selected_shape_type=None):

        self.createMode = createMode
        if edit_flags == True:
            self.createMode = selected_shape_type
            # print("edit_flags TRUE")
            # polygon_list = ["flatness_A", "flatness_B", "flatness_C", "flatness_D", "flatness_E",
            #                 "walkway_block", "walkway_paved", "paved_state_broken", "paved_state_normal",
            #                 "block_state_broken", "block_state_normal", "block_kind_bad", "block_kind_good",
            #                 "outcurb_rectangle", "outcurb_rectangle_broken",
            #                 "outcurb_slide", "outcurb_slide_broken", "restspace", "sidegap_in", "sidegap_out",
            #                 "sewer_cross", "sewer_line", "brailleblock_dot", "brailleblock_dot_broken",
            #                 "brailleblock_line", "brailleblock_line_broken", "continuity_manhole", "continuity_tree",
            #                 "ramp_yes", "ramp_no", "bicycleroad_broken", "bicycleroad_normal", "planecrosswalk_broken",
            #                 "planecrosswalk_normal", "bump_slow", "bump_zigzag", "weed", "floor_broken", "floor_normal",
            #                 "flowerbed", "parkspace", "enterrail", "fireshutter", "stair_normal", "stair_broken",
            #                 "wall","resting_place_roof", "reception_desk"]
            # for i in range(len(polygon_list)):
            #     if text == polygon_list[i]:
            #         self.createMode = "polygon"
            #     else:
            #         self.createMode = "rectangle"
            self.edit.setText(text)
        self.changedComboboxFirst(str(self.combobox_first.currentText()))


        # self.createMode = createMode

        # if text:
        #     self.edit.setText(text)
        #     print(self.combobox_first.currentText())
        #     # self.changedComboboxFirst(str(self.combobox_first.currentText()))
        #     print(self.combobox_third.currentText())
        # else:
        #     self.changedComboboxFirst(str(self.combobox_first.currentText()))


        # self.edit.setText(text)
        # self.changedComboboxSecond(str(self.combobox_second.currentTextChanged()))
        # self.changedCombobox(str(self.combobox_third.currentTextChanged()))

        if self._fit_to_content["row"]:
            self.labelList.setMinimumHeight(
                self.labelList.sizeHintForRow(0) * self.labelList.count() + 2
            )
        if self._fit_to_content["column"]:
            self.labelList.setMinimumWidth(
                self.labelList.sizeHintForColumn(0) + 2
            )
        # if text is None, the previous label in self.edit is kept
        if text is None:
            text = self.edit.text()
        if flags:
            self.setFlags(flags)
        else:
            self.resetFlags(text)
        self.edit.setText(text)
        self.edit.setSelection(0, len(text))
        if group_id is None:
            self.edit_group_id.clear()
        else:
            self.edit_group_id.setText(str(group_id))
        items = self.labelList.findItems(text, QtCore.Qt.MatchFixedString)

        if items:
            if len(items) != 1:
                logger.warning("Label list has duplicate '{}'".format(text))
            self.labelList.setCurrentItem(items[0])
            row = self.labelList.row(items[0])
            self.edit.completer().setCurrentRow(row)
        self.edit.setFocus(QtCore.Qt.PopupFocusReason)
        if move:
            qr = self.frameGeometry()
            cp = QtWidgets.QDesktopWidget().availableGeometry().center()
            qr.moveCenter(cp)
            self.move(qr.topLeft())
            # self.move(QtGui.QCursor.pos())
        if createMode == "blur_p":
            return "blur_p", {}, None
        elif createMode == "blur_b":
            return "blur_b", {}, None
        elif self.exec_():
            return self.edit.text(), self.getFlags(), self.getGroupId()
        else:
            return None, None, None